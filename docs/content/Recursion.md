---
icon: material/graph
---


### تابع بازگشتی
تابع بازگشتی یک تکنیک برنامه نویسی هستش که توی اون تابع توی خودش خودش رو صدا میکنه با پارامتر های متفاوت تا زمانی که به حالت پایه خودش برسه و متوقف بشه. <br>
> عملا به ما امکان این رو میده که مسئله رو به زیر مسئله های کوچیک تر و قابل مدیریت تر تجزیه کنیم و راه حل های زیبا و خلاقانه ای ارائه بدیم.

احتمالا گیج شدین ولی ایرادی نداره بریم چند تا مثال ببینیم:

#### مثال 1

$f(n) = n!$ <br>
این تابع فاکتوریل هستش که احتمالا باهاش آشنا هستین و خب ما اگه بخوایم این رو به صورت یک عبارت بازگشتی بنویسیم به این شکل خواهد بود: <br>
$f(n) = n * f(n - 1)$ <br>
یک حالت پایه هم میخوایم که وقتی به اون رسیدیم متوقف بشه کار که اون صفر هستش ($f(0) = 1$) <br>
به دو حالت میشه کد این تابع رو زد:

=== "For loop & Array"

    ```cpp
    #include <iostream>
    using namespace std;

    int main(){
        int n = 10;
        int f[n];
        f[0] = 1; // (1)!
        for (int i = 1; i < 10; i++){
            f[i] = i * f[i - 1]; // (2)!
        }
        cout << f[9];
        // output:
        // 362880 -> 9!
        return 0;
    }
    ```

    1. این همون حالت پایه هستش که گفته شد.

    2. این همون عبارت بازگشتی تابع فاکتوریل هستش به این شکل که در حال حاضر مقادیر `f[0]` تا `f[i-1]` حساب شدن و  حالا میخوایم مقدار `f[i]` رو محاسبه کنیم.

=== "Recursive Function"

    ```cpp
    #include <iostream>
    using namespace std;

    int f(int n){
        if (n == 0){
            return 1; // (1)!
        }
        return n * f(n - 1); // (2)!
    }

    int main(){
        cout << f(4);
        // output:
        // 24 -> 4!
        return 0;
    }
    ```

    1. تابع انقد صدا زده میشه و به زیر مسئله کوچیکتر تبدیل میشه که در نهایت برسه به حالت پایه که صفر هست و تو این `if` هندل میشه.

    2. این عبارتمونه و همونطور که میبینین تابع توی خودش صدا زده شده و مسئله به یک زیر مسئله کوچیکتر (n - 1 تایی) تبدیل شده.

میتونیم روند انجام عملیات ها توی تابع بازگشتی رو به صورت نمودار زیر ببینیم:

``` mermaid
graph LR
  A[Output] --> |Call f4 in main| B[f4];
  B --> |Call f3 in f4| C[f3];
  C --> |Call f2 in f3| D[f2];
  D --> |Call f1 in f2| E[f1];
  E --> |Call f0 in f1| F[f0];
  F --> |return f0| E;
  E --> |f1 = return 1 * f0| D;
  D --> |f2 = return 2 * f1| C;
  C --> |f3 = return 3 * f2| B;
  B --> |f4 = return 4 * f3| A;
```

> به عبارتی وقتی از توی `main` تابع `f(4)` صدا زده میشه یک روند بازگشتی شروع میشه با صدا کردن حالت یدونه کوچیکتر تا در نهایت به 
`f(0)` میرسه که همون حالت پایه اس و هر حالت مقدار خودش رو به ترتیب `return` میکنه برای حالت یدونه بزرگترش و همینجوری انگار همون مسیر رفته رو برمیگرده و همه از `f(1)` تا `f(4)` به ترتیب حساب میشن و در نهایت خروجی میره به سمت `main`.

عملا وقتی کامپایلر داره تابع رو اجرا میکنه و پارامترش `n = 4` هستش و در `Function body` مقدار `f(3)` صدا زده شده کامپایلر انگار میره یک صفحه جدید باز میکنه برای خودش و از اول تابع رو شروع میکنه به ران کردن ولی این دفعه با پارامتر `n = 3` در نهایت وقتی به `return` رسید تو این حالت مقداری که `return` شده رو میفرسته به صفحه قبلی که توش بود یا عملا `Function body` حالت `n = 4` و این مقدار رو به جای `f(3)` استفاده میکنه.


!!!warning "اشتباه رایج"
    خیلی ها دقت نمیکنن و تابع بازگشتی بالارو به این شکل پیاده میکنن:

    ```cpp
    #include <iostream>
    using namespace std;

    int f(int n){
        return n * f(n - 1);
        if (n == 0){
            return 1;
        }
    }

    int main(){
        cout << f(4);
        return 0;
    }
    ```

    در اینجا چون شرط بررسی اینکه به حالت پایه رسیدیم رو پایین تر از خطی نوشتیم که داریم حالت کوچیکتر رو صدا میکنیم تابع هیچ وقت شرط رو بررسی نمیکنه و تا ابد همینطوری مقدار کوچیکتر رو صدا میکنه.
    ``` mermaid
    graph LR
        A[Output] --> B[f.4];
        B --> C[f.3];
        C --> D[f.2];
        D --> E[f.1];
        E --> F[f.0];
        F --> G[f.-1];
        G --> H[f.-2];
        H --> I[...];
    ```

    پس احتمالا الان فهمیدین که چرا ما حالت پایه تعریف میکنیم به خاطر اینکه یه جا تابع باید متوقف بشه و تا ابد همینطوری قبلی اش رو صدا نکنه :smile:

    <b>و حواستون هم باشه پس که همیشه شرط بررسی اینکه به حالت پایه رسیدیم یا نه رو همون اول بررسی کنید! </b>

---

#### مثال 2

$f(n) = f(n - 1) + f(n - 2)$ <br>
این تابع فیبوناچی هستش که احتمالا باهاش آشنا هستین.
حالت پایه فیبوناچی دوتا عدد هست بدین شکل:

- $f(0) = 0$

- $f(1) = 1$

و کدش رو میشه به دو حالت پیاده سازی کرد:

=== "For loop & Array"

    ```cpp
    #include <iostream>
    using namespace std;

    int main(){
        int f[10];
        f[0] = 0;
        f[1] = 1;
        for (int i = 2; i < 10; i++){
            f[i] = f[i - 1] + f[i - 2];
        }
        cout << f[9];
        // output:
        // 34
        return 0;
    }
    ```

=== "Recursive Function"

    ```cpp
    #include <iostream>
    using namespace std;

    int f(int n){
        if (n == 0){
            return 0;
        }
        if (n == 1){
            return 1;
        } // (1)!
        return f(n - 1) + f(n - 2);
    }

    int main(){
        cout << f(4);
        // output:
        // 3
        return 0;
    }
    ```

    1. چون دوتا حالت پایه داریم جفتش رو بررسی میکنیم همین اول تابع.

چون تابع بازگشتی فقط یک بار خودش رو صدا نزده بلکه دوبار خودش رو صدا زده توی خودش , نمودارش به این شکل در میاد (درخت میشه):

![Recursive](../assets/CLwKE.jpg)

پایین ترین مقدار ها که دیگه پایین تر نرفتن میشن حالت های پایه ما (`f(0) & f(1)`) که وقتی به اون ها رسیدیم پروسه `return` کردن شروع میشه و مقادیر به سمت بالا برمیگردن تا برسن به مقدار بالایی که `f(4)` هستش.

!!! note "چرا دوتا مقدار پایه داریم؟"
    به این علت که ما توی تابع مون دوبار خود تابع رو صدا میکنیم یا به عبارتی از دو تا مقدار کوچیکتر استفاده میکنیم برای حساب کردن مقدار مورد نظر. پس یک نقطه ای باید باشه که تابع مون از <b>دو تا مقدار پایه</b> استفاده کنه برای حساب کردن مقدار فعلی وگرنه تا ابد همینجوری تابع صدا کردن مقدار کوچیکتر رو ادامه خواهد داد.

---

### Backtracking

بک ترکینگ (پس گرد) یک استراتژی حل مسئله هستش که با استفاده از تابع بازگشتی و حساب کردن همه حالت های ممکن و بررسی حالت های درست و نادرست به حل مسئله میپردازد.

#### مسئله
یک وکتور داریم و میخواهیم تمام زیر مجموعه های ممکن این وکتور رو چاپ کنیم.

```cpp
#include <iostream>
#include <vector>
using namespace std;

void f(vector<int> Vec, vector<int> Ans, int i){
    if (i == Vec.size()){
        cout << "{ ";
        for (int x: Ans){
            cout << x << ' ';
        }
        cout << '}' << endl;
        return;
    }
    
    Ans.push_back(Vec[i]);
    f(Vec, Ans, i + 1);
    Ans.pop_back();
    f(Vec, Ans, i + 1);
}

int main(){
    vector<int> Vec = {1, 2, 3};
    f(Vec, {}, 0); // (1)!
    // Output:
    // { 1 2 3 }
    // { 1 2 }
    // { 1 3 }
    // { 1 }
    // { 2 3 }
    // { 2 }
    // { 3 }
    // { }
    return 0;
}
```

1. اینجا میخواستم وکتور خالی بفرستم به پارامتر `Ans` تابع و به این شکل نوشتمش. <br>
 مقدار اولیه دادن به وکتور به این شکل بود `{3 ,2 ,1}` پس با این اوصاف وکتور خالی میشه `{}`.

 <b> استراتژی چیه؟ </b> (با شکل نمودار بازگشتی راحت تر میفهمین) <br>
به طور کلی ما میخوایم به شکل بازگشتی تمام زیر مجموعه هارو بسازیم. <br>
یک متغیر `i` میگیریم که برابر خونه وکتوری هستش که در حال حاضر روش هستیم. <br>
میخوایم به طور بازگشتی تمام زیر مجموعه های مقدار های وکتور از `i` تا آخر رو بسازیم و به همراه مقادیر فعلیه وکتور `Ans` خروجی بدیم. (یک سری مقادیر هستن توی وکتور `Ans` که در استیت های قبلی بازگشتی از خونه های `0` تا `i-1` پوش بک شدن) <br> 
این زیر مجموعه ها به دو دسته تقسیم میشن یا دارای مقدار خونه `i` وکتور `Vec` هستن یا نیستن. <br>
پس ما دو بار تابع رو صدا میکنیم: <br>

- زیر مجموعه هایی که خونه `i` درونشون باشه. <br>
    پس چون قراره خونه `i` رو داشته باشیم اون رو پوش بک میکنیم درون `Ans`. <br>
    و میگیم حالا برو همه زیر مجموعه های از خونه `i+1` تا آخر رو با `Ans` خروجی بده. <br>

- زیر مجموعه هایی که خونه `i` درونشون نباشه. <br>
    همون مثل حالت قبله فقط `i` رو از درون `Ans` پاپ بک میکنیم و میگیم دوباره برو و همه زیر مجموعه های از `i+1` تا آخر رو خروجی بده فقط این دفعه بدون وجود `i` درون اون زیر مجموعه ها. <br>

> حالت پایه هم وقتیه که همه عدد های وکتور Vec رو دیدیم و تموم شدن حالا باید نتیجه Ans فعلی رو خروجی بدیم.


اگه بخوایم نمودار بازگشتی رو بکشیم باز به شکل درخت خواهد شد چون دوبار خودش رو صدا کردیم درون `Function body`:

![Backtracking](../assets/Back.jpg)