---
icon: material/alphabetical
---

قبلا به طور جزئی با رشته ها آشنا شدید. از این تایپ برای ذخیره سازی رشته هایی از کاراکتر ها استفاده می کنیم.

```cpp
string s = "hello world!";
```

برای استفاده از استرینگ ها به کتابخونه `string` نیاز دارید. (هرچند که توی `bits/stdc++.h` وجود داره)

```cpp
#include<string>
```

## چند خاصیت رشته ها

رشته ها خاصیت جمع پذیری دارن و این کار به صورتی انجام میشه که رشته دوم به انتهای رشته اول اضافه میشه..

```cpp
string firstName = "iliya";
string lastName = "afzali"; 

string fullName = firstName + " " + lastName;

// fullName: iliya afzali
```

!!! danger
    حواستون باشه که تفریق رشته ها از هم کاملا بی معنیه و با ارور مواجه میشید!
    ```cpp
    string s = "abab", r = "ab";
    string tmp = s - r; // ❌
    ```

    ```cpp
    invalid operands to binary expression ('string' (aka 'basic_string<char>') and 'string')
       16 |     string tmp = s - r;
          |                  ~ ^ ~
    ```

استرینگ ها در عمل یک **آرایه** از کاراکتر ها هستند پس ما این انتظار رو داریم که خواص آرایه ها رو نیز دارا باشند.

به عنوان مثال مانند آرایه ها میشه به یک کاراکتر از استرینگ دسترسی پیدا کرد یا حتی اون رو تغییر داد.

```cpp
string s = "some string";

cout << s[2] << endl;
// output: m

s[0] = 'S';
s[3] = 'E';

cout << s << endl;
// output: SomE string
```

!!! tip "ASCII code"
    طبق یک [قرارداد و استاندارد](https://www.ascii-code.com) هر یک از کاراکتر ها به یک عدد مخصوص به خودش ارتباط داده
    میشه و به این جدول اعداد منسوب، `ascii table` و به هر کدوم از این اعداد `ascii code` میگیم.

    * اعداد  از کد 48 تا 57
    * حروف بزرگ از کد 65 تا 90 
    * حروف کوچک بعد از آنها از کد 97 تا 122
    
    رو به خود اختصاص دادن.

    برای دیدن کد هر کاراکتر میتونیم اون رو به طور [ضمنی](https://en.cppreference.com/w/c/language/conversion.html) به
    `int` تبدیل کنیم.

    ```cpp
    cout << int('a');

    // output: 97
    ```

    و همچنین از تبدیل ضمنی اعداد به کاراکتر ها، طبق جدول `ascii` می تونیم به کاکتر مورد نظر برسیم.
    ```cpp
    cout << char(97);
    
    // output: a
    ```

---

## مقایسه رشته ها

عملگرهای مقایسه ای همونطور که روی `int` ها تعریف میشه، روی رشته ها هم تعریف میشه به این صورت که میتونید از (`>=, <=, ==,
<, >, !=, ...`) برای مقایسه رشته ها هم استفاده کنید.

و این مقایسه به صورت [lexicographical order](https://en.wikipedia.org/wiki/Lexicographic_order) انجام میشه.

!!! note "lexicographical order"
    به طور خلاصه مقایسه lexicographic بین دو رشته `a` و `b` به صورت زیر انجام میشه.

    * اگر دو رشته برابر بودن که طبعا حالت مساوی رخ میده
    * رشته `a` برابر با یک پیشوند از `b` است که در این صورت `a` کوچکتر از `b` لحاظ میشه.
    * رشته `a` یک پیشوند از `b` نیست و در نتیجه در یک حرف اختلاف دارن. در این صورت برحسب اولین حرف از چپ که این دو رشته
        در اون اختلاف دارن، مقایسه انجام میشه.

    به عنوان مثال:
    ```cpp
    "ali" < "alireza"

    "Abas" < "abas" //(1)!

    "abczzzzz" < "abeaa"
    ```

    1. از اونجایی که بر حسب جدول `ascii`، حروف بزرگ اعداد کوچکتری نسبت به حروف کوچک اختیار می کنن!

---

## توابع مربوط به رشته ها

در تمامی توابع زیر، رشته ای که روی اون تابع اجرا میشه رو طبق تعریف زیر در نظر بگیرید.

```cpp
string s = "hello world again!";
```

### ()s.size

تابع `s.size()` یا `s.length` هر دو تعداد کاراکتر های رشته رو خروجی میدن.

```cpp
cout << s.size() << endl;

// output: 18
```

این تابع وقتی به کار میاد که ما یک رشته از ورودی دریافت می کنیم و اطلاعی از اندازه اون ورودی نداریم.

```cpp
string r;
cin >> r;

cout << r.size();

// input: ajab
// output: 4
```

یا قراره در ادامه به کمک یک حلقه، روی تک تک کاراکتر های اون رشته حرکت کنیم و کاری انجام بدیم.

```cpp
string r;
cin >> r;

for (int i = 0; i < r.size(); i++) {
    cout << r[i] << '-';
}

// input: snake
// output: s-n-a-k-e-
```

!!! warning
    مثل آرایه ها، در رشته ها هم ایندکسینگ از 0 شروع میشه و تا `s.size() - 1` که کاراکتر آخر رشته باشه ادامه داره. در
    نتیجه شما باید برای دسترسی به کاراکتر آخر یک رشته به طور زیر عمل کنید.

    ```cpp
    cout << s[s.size() - 1];

    // output: !
    ```

### ()s.at

مثل عملگر `[]` رفتار میکنه و کاراکتر واقع در یک ایندکس رو به شما بر میگردونه.

```cpp
cout << s.at(3) << endl;
// output: l

cout << s[3] << endl;
// output: l
```

### ()s.substr

به ترتیب دو آرگومان `START_POS` و `SIZE` رو دریافت میکنه و یک زیر رشته از استرینگ داده شده با شروع از `START_POS` و به
اندازه `SIZE` بر می گردونه.

```cpp
cout << s.substr(0, 5);
// output: hello

cout << s.substr(2, 4);
// output: llo wo
```

### ()s.find

یک رشته به عنوان آرگومان دریافت میکنه و در رشته اصلی دنبال جایگاه شروع اولین تکرار اون می گرده.

```cpp
cout << s.find("again");
// output: 12
```

اگر آرگومان داده شده در رشته اصلی وجود نداشته باشه `string::npos` بر می گردونه.

```cpp
if (s.find("sldkfja") == string::npos) {
    cout << "not found!" << endl;
}

// output: not found!
```

### vector functions

همچنین رشته ها خواص `vector` ها رو دارن و میشه از توابع زیر دقیقا مثل `vector` ها استفاده کرد.

```cpp
s.pop_back(); // پاک کردن کاراکتر آخر

s.push_back('!'); // اضافه کردن یک کاراکتر به آخر رشته

s.empty(); // بررسی خالی بودن رشته

sort(s.begin(), s.end()); // مرتب سازه رشته بر حسب اسکی کد
```
